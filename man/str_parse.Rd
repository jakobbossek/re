% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/str_parse.R
\name{str_parse}
\alias{str_parse}
\title{Parse strings}
\usage{
str_parse(x, ext = NULL, which = NULL, types, names, as.df = TRUE,
  append = TRUE, ...)
}
\arguments{
\item{x}{[\code{character}]\cr
Input strings.}

\item{ext}{[\code{character(1) | NULL}]\cr
Optional file extension which should be dropped prior to splitting.}

\item{which}{[\code{integer}]\cr
Integer vector of relevant positions, i.e. positions in the exploded string which
are of interest. Defaults to all positions.}

\item{types}{[\code{character(1)}]\cr
Single character where the letter at position i characterizes the type of
the corresponding element in the exploded string.
Possible letters are \dQuote{c} (character), \dQuote{n} (numeric), \dQuote{i}
(integer) or \dQuote{l} (logical).}

\item{names}{[\code{character}]\cr
Vector of names for the extracted components.}

\item{as.df}{[\code{logical(1)}]\cr
Should the result be a data frame?
Default is \code{TRUE}. If \code{FALSE} a list of named lists is returned.}

\item{append}{[\code{logical(1)}]\cr
Should the values of \code{x} be dropped or appended to the ouptut via
component \dQuote{input}?
Default is \code{TRUE}.}

\item{...}{[any]\cr
Further arguments passed down to \code{\link[base]{strsplit}}.
Here, argument \code{split} is the most interesting one.}
}
\value{
[\code{data.frame | list}]
}
\description{
Split character vector, i.e. each element, by a seperator and convert the resulting
exploded string into a typed list / data frame of meta information.
}
\examples{
x = c("char_int10_num10.4", "char_int28_num30.444")
str_parse(x, types = "cin", names = c("character", "integer", "numeric"), split = "_")
str_parse(x, which = 2:3, types = "in", names = c("integer", "numeric"), split = "_")
str_parse(x, which = 2:3, types = "in", names = c("integer", "numeric"),
  as.df = FALSE, append = FALSE, split = "_")
}
